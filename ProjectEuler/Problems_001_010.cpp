#include "ProjectEuler.h"

#include <iostream>

using namespace std;

#include <list>
#include <vector>
#include <set>

/*
Multiples of 3 and 5
Problem 1
If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.
*/

void Problem_001_bruteforce(void)
{
	// simples, brute force solution
	const int upperBound = 1000;
	int sumOf3Or5Multiplies = 0;
	for (int i = 0; i < upperBound; ++i)
	{
		if (0 == i%3)
		{
			sumOf3Or5Multiplies += i;
		}
		else if (0 == i%5)
		{
			sumOf3Or5Multiplies += i;
		}
	}

	cout << sumOf3Or5Multiplies << endl;
}

void Problem_001(void)
{
	const int upperBound = 1000;
	int sumOf3Or5Multiplies = 0;

	for (int i = 3; i < upperBound; i = i + 3)
	{
		sumOf3Or5Multiplies += i;
	}
	for (int i = 5; i < upperBound; i = i + 5)
	{
		sumOf3Or5Multiplies += i;
	}
	for (int i = 15; i < upperBound; i = i + 15)
	{
		sumOf3Or5Multiplies -= i;
	}

	cout << sumOf3Or5Multiplies << endl;
}

/*
Even Fibonacci numbers
Problem 2
Each new term in the Fibonacci sequence is generated by adding the previous two terms.By starting with 1 and 2, the first 10 terms will be :

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even - valued terms.
*/

void Problem_002(void)
{
	int previousElement = 1;
	int currentElement = 2;

	int sumOfFibonacciEvenValuedTerms = previousElement;

	while (currentElement < 4000000)
	{
		int temp = currentElement;
		currentElement = currentElement + previousElement;
		previousElement = temp;

		if (1 == currentElement % 2)
		{
			sumOfFibonacciEvenValuedTerms += currentElement;
		}
	}

	cout << sumOfFibonacciEvenValuedTerms << endl;
}

/*
Largest prime factor
Problem 3
The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?
*/

static long long findNextPrimeNumber(long long currentPrimeNumber)
{
	long long newPrimeNumber = currentPrimeNumber;

	bool flagNewPrimeNumberFound = false;

	while (!flagNewPrimeNumberFound)
	{
		newPrimeNumber++;
		flagNewPrimeNumberFound = true;

		long long upperLimit = newPrimeNumber / 2;
		if (newPrimeNumber <= 4)
		{
			upperLimit = newPrimeNumber;
		}
		for (int i = 2; i < upperLimit; ++i)
		{
			if (newPrimeNumber % i == 0)
			{
				flagNewPrimeNumberFound = false;
				break;
			}
		}
	}

	return newPrimeNumber;
}

void Problem_003(void)
{
	long long valueToCheck = 600851475143; // 13195;

	long long currentPrimeNumber = 2;

	list<long long> listOfPrimeFactors;

	// testing findNextPrimeNumber function 
	/*
	int primeNumber = 1;
	for (int i = 0; i < 50; ++i)
	{
		primeNumber = findNextPrimeNumber(primeNumber);
		cout << primeNumber << endl;
	}
	*/

	while (currentPrimeNumber <= valueToCheck)
	{
		if (0 == (valueToCheck % currentPrimeNumber))
		{
			listOfPrimeFactors.push_front(currentPrimeNumber);
			valueToCheck = valueToCheck / currentPrimeNumber;
			cout << listOfPrimeFactors.front() << endl;
		}
		currentPrimeNumber = findNextPrimeNumber(currentPrimeNumber);	
	}
}

/*
Largest palindrome product
Problem 4
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

Find the largest palindrome made from the product of two 3-digit numbers.
*/

void Problem_004(void)
{
	char valueAsString[7];
	// bruteforce powa!
	for (int i = 999; i > 99; --i)
	{
		bool flagIsPalindrom = false;

		for (int j = 999; j > 99; --j)
		{
			int product = i*j;
			itoa(product, valueAsString, 10);
			int length = strlen(valueAsString);
			flagIsPalindrom = true;
			for (int k = 0; k < length / 2; ++k)
			{
				if (valueAsString[k] != valueAsString[length - (k+1)])
				{
					flagIsPalindrom = false;
					break;
				}
			}

			if (flagIsPalindrom)
			{
				cout << i << ", " << j << endl;
				break;
			}
		}
		if (flagIsPalindrom)
		{
			break;
		}
	}
}

/*
Smallest multiple
Problem 5
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
*/

void Problem_005(void)
{
	// this time no brute force methods allowed!
	list<int> multipliers;
	multipliers.push_front(2);

	for (int i = 3; i < 21; ++i)
	{
		int currentValue = i;
		int valueToAdd = i;
		for (auto iter = multipliers.begin(); iter != multipliers.end(); ++iter)
		{
			if ((0 == (currentValue % *iter)))
			{
				currentValue = currentValue / (*iter);
				valueToAdd = currentValue;
			}
		}
		if (1 != valueToAdd)
		{
			multipliers.push_back(valueToAdd);
		}
	}

	int smallestMultiple = 1;
	for (auto item : multipliers)
	{
		smallestMultiple *= item;
	}

	cout << smallestMultiple << endl;
}

/*
Sum square difference
Problem 6
The sum of the squares of the first ten natural numbers is,

1^2 + 2^2 + ... + 10^2 = 385
The square of the sum of the first ten natural numbers is,

(1 + 2 + ... + 10)^2 = 55^2 = 3025
Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.

Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
*/

void Problem_006(void)
{
	const int upperBound = 20;

	int sumOfTheSquares = 0;
	int squareOfTheSum = 0;
	
	for (int i = 1; i <= upperBound; ++i)
	{
		sumOfTheSquares += i*i;
		squareOfTheSum += i;
	}
	squareOfTheSum = pow(squareOfTheSum, 2);

	cout << (sumOfTheSquares - squareOfTheSum) << endl;

}

/*
10001st prime
Problem 7
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.

What is the 10 001st prime number?
*/

void Problem_007(void)
{
	const int n = 10001;
	int nthPrimeNumber = 2;

	for (int i = 0; i < n; ++i)
	{
		nthPrimeNumber = findNextPrimeNumber(nthPrimeNumber);
	}
	cout << nthPrimeNumber << endl;
}

/*
Largest product in a series
Problem 8
The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.

73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450

Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
*/

int calculateProduct(const std::vector<int>& vec)
{
	int product = 1;
	for (auto item : vec)
	{
		product *= item;
	}
	return product;
}

void Problem_008(void)
{
	const int numberOfAdjacentDigits = 13;

	std::string numberAsString = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";

	std::vector<int> numbers;
	for (auto item : numberAsString)
	{
		int currentDigit = (int)(item - '0');
		if (currentDigit < 0 || currentDigit >9)
		{
			cout << "error" << endl;
		}
		numbers.push_back(currentDigit);
	}

	std::vector<int> bestSet(numbers.begin(), numbers.begin() + numberOfAdjacentDigits);
	int largestProduct = calculateProduct(bestSet);
	cout << largestProduct << endl;

	for (auto itr = numbers.begin() + numberOfAdjacentDigits; itr != numbers.end(); ++itr)
	{
		std::vector<int> currentSet(itr - numberOfAdjacentDigits, itr);
		int currentProduct = calculateProduct(currentSet);

		if (largestProduct < currentProduct)
		{
			largestProduct = currentProduct;
			bestSet = currentSet;
		}
	}

	for (auto item : bestSet)
	{
		cout << item << ", ";
	}
	cout << endl;
}

/*
Special Pythagorean triplet
Problem 9
A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

a^2 + b^2 = c^2
For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
*/

void Problem_009(void)
{
	const int givenValue = 1000;
	// using the constraints:
	// a^2 + b^2 = c^2 and a+b+c=1000
	// following formulas can be found:
	// c = 1000 - a - b
	// a = (1000 * (b - 500)) / (b - 1000)
	// both a and b has to be natural so (1000 * (b-500)) modulo (b-1000) shoule give 0

	int a = 0;
	int b = 0;
	for (int i = 1; i < 1000/3; ++i)
	{
		int nominator = givenValue * (i - givenValue / 2);
		int denominator = i - givenValue;

		if ((nominator % denominator) == 0)
		{
			a = nominator / denominator;
			b = i;
			break;
		}
	}
	int c = givenValue - a - b;

	cout << a << ", " << b << ", " << c << endl;
}

/*
Summation of primes
Problem 10
The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below two million.
*/

/*
Result:
Project Euler go go go!
2000003
142913828922
*/

void Problem_010(void)
{
	const long long TWO_MILIONS_BRO_SERIOUS_SHIT = 2000000;
	const long long upperBound = TWO_MILIONS_BRO_SERIOUS_SHIT;
	long long currentPrimeNumber = 2;
	long long sumOfPrimeNumbers = 0;

	while (currentPrimeNumber < upperBound)
	{
		sumOfPrimeNumbers += currentPrimeNumber;
		currentPrimeNumber = findNextPrimeNumber(currentPrimeNumber);
	}

	cout << currentPrimeNumber << endl;
	cout << sumOfPrimeNumbers << endl;
}

/*
Largest product in a grid
Problem 11
In the 20×20 grid below, four numbers along a diagonal line have been marked in red.

08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48

The product of these numbers is 26 × 63 × 78 × 14 = 1788696.

What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
*/

static inline int CharToInt(const char& value)
{
	return (value - '0');
}

void Problem_011(void)
{
	string inputData = "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48";

	const int gridSize = 20;
	vector<vector<int>> grid;
	const int sizeOfBest = 4;

	
	for (int i = 0; i < gridSize; i++)
	{
		vector<int> newVector;
		for (int j = 0; j < gridSize; j++)
		{
			int index = 3 * (i * 20 + j);
			int value = CharToInt(inputData[index]) * 10 + CharToInt(inputData[index+1]);
			newVector.push_back(value);
		}
		grid.push_back(newVector);
	}

	// horizontal round
	int horizontalBestPositionI = 0;
	int horizontalBestPositionJ = 0;
	int horizontalBest = grid[horizontalBestPositionI][horizontalBestPositionJ] * grid[horizontalBestPositionI][horizontalBestPositionJ + 1] * grid[horizontalBestPositionI][horizontalBestPositionJ + 2] * grid[horizontalBestPositionI][horizontalBestPositionJ + 3];
	int horizontalCurrent = 1;
	for (int i = 0; i < gridSize; i++)
	{
		for (int j = 0; j < (gridSize - sizeOfBest); j++)
		{
			horizontalCurrent = grid[i][j] * grid[i][j + 1] * grid[i][j + 2] * grid[i][j + 3];

			if (horizontalCurrent > horizontalBest)
			{
				horizontalBest = horizontalCurrent;
				horizontalBestPositionI = i;
				horizontalBestPositionJ = j;
			}
		}
	}

	cout << "Horizontal best position: " << horizontalBest << ", at: " << horizontalBestPositionI << ", " << horizontalBestPositionJ << endl;

	// vertical round
	int verticalBestPositionI = 0;
	int verticalBestPositionJ = 0;
	int verticalBest = grid[verticalBestPositionI][verticalBestPositionJ] * grid[verticalBestPositionI + 1][verticalBestPositionJ] * grid[verticalBestPositionI + 2][verticalBestPositionJ] * grid[verticalBestPositionI + 3][verticalBestPositionJ];
	int verticalCurrent = 1;
	for (int i = 0; i < (gridSize - sizeOfBest); i++)
	{
		for (int j = 0; j < gridSize; j++)
		{
			verticalCurrent = grid[i][j] * grid[i + 1][j] * grid[i + 2][j] * grid[i + 3][j];

			if (verticalCurrent > verticalBest)
			{
				verticalBest = verticalCurrent;
				verticalBestPositionI = i;
				verticalBestPositionJ = j;
			}
		}
	}

	cout << "Vertical best position: " << verticalBest << ", at: " << verticalBestPositionI << ", " << verticalBestPositionJ << endl;

	// diagonally up-left to down-right, round
	int diagonally1BestPositionI = 0;
	int diagonally1BestPositionJ = 0;
	int diagonally1Best = grid[diagonally1BestPositionI][diagonally1BestPositionJ] * grid[diagonally1BestPositionI + 1][diagonally1BestPositionJ] * grid[diagonally1BestPositionI + 2][diagonally1BestPositionJ] * grid[diagonally1BestPositionI + 3][diagonally1BestPositionJ];
	int diagonally1Current = 1;
	for (int i = 0; i < (gridSize - sizeOfBest); i++)
	{
		for (int j = 0; j < (gridSize - sizeOfBest); j++)
		{
			diagonally1Current = grid[i][j] * grid[i + 1][j + 1] * grid[i + 2][j + 2] * grid[i + 3][j + 3];

			if (diagonally1Current > diagonally1Best)
			{
				diagonally1Best = diagonally1Current;
				diagonally1BestPositionI = i;
				diagonally1BestPositionJ = j;
			}
		}
	}

	cout << "Diagonally up-left to down-right best position: " << diagonally1Best << ", at: " << diagonally1BestPositionI << ", " << diagonally1BestPositionJ << endl;

	// diagonally up-right to down-left, round
	int diagonally2BestPositionI = 0;
	int diagonally2BestPositionJ = 0;
	int diagonally2Best = grid[diagonally2BestPositionI][diagonally2BestPositionJ] * grid[diagonally2BestPositionI + 1][diagonally2BestPositionJ] * grid[diagonally2BestPositionI + 2][diagonally2BestPositionJ] * grid[diagonally2BestPositionI + 3][diagonally2BestPositionJ];
	int diagonally2Current = 1;
	for (int i = sizeOfBest; i < gridSize; i++)
	{
		for (int j = 0; j < (gridSize - sizeOfBest); j++)
		{
			diagonally2Current = grid[i][j] * grid[i - 1][j + 1] * grid[i - 2][j + 2] * grid[i - 3][j + 3];

			if (diagonally2Current > diagonally2Best)
			{
				diagonally2Best = diagonally2Current;
				diagonally2BestPositionI = i;
				diagonally2BestPositionJ = j;
			}
		}
	}

	cout << "Diagonally up-right to down-left best position: " << diagonally2Best << ", at: " << diagonally2BestPositionI << ", " << diagonally2BestPositionJ << endl;

	list<int> bestScore;
	bestScore.push_back(horizontalBest);
	bestScore.push_back(verticalBest);
	bestScore.push_back(diagonally1Best);
	bestScore.push_back(diagonally2Best);
	bestScore.sort();

	cout << "Best overall: " << bestScore.back() << endl;
}

/*
Highly divisible triangular number
Problem 12
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

1: 1
3: 1,3
6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
*/

void GetSmallerPart(int value, int maxValue, vector<int>& set)
{
	set.push_back(value);

	if (value < maxValue)
	{
		GetSmallerPart(value + 1, maxValue, set);
	}
}

vector<vector<int>> GeneratePermutations(int lowValue, int highValue)
{
	cout << "Permutations" << endl;
	vector<vector<int>> permutations;
	for (int startValue = lowValue; startValue < highValue; startValue++)
	{
		for (int endValue = startValue; endValue < highValue; endValue++)
		{
			vector<int> newPermutations;
			GetSmallerPart(startValue, endValue, newPermutations);

			for (auto item : newPermutations)
			{
				cout << item << ", ";
			}
			cout << endl;
		}
	}
	cout << endl;

	return permutations;
}

typedef unsigned long long Problem_012_t;

Problem_012_t Multiplication(const vector<Problem_012_t>& data, int index, int maxIndex)
{
	Problem_012_t result = 1;

	if (index <= maxIndex)
	{
		result = data[index] * Multiplication(data, index + 1, maxIndex);
	}

	return result;
}

vector<Problem_012_t> AllPossibleMultiplicationsInSet(const vector<Problem_012_t>& data, Problem_012_t maxValueAllowed)
{
	vector<Problem_012_t> multiplications;

	int lowValue = 0;
	int highValue = data.size();

	for (int startValue = lowValue; startValue < highValue; startValue++)
	{
		for (int endValue = startValue + 1; endValue < highValue; endValue++)
		{
			// stupid recursive version
			//Problem_012_t newMultiplication = Multiplication(data, startValue, endValue);
			bool flagAddValue = true;
			Problem_012_t newMultiplication = 1;
			for (int i = startValue; i <= endValue; i++)
			{
				if (newMultiplication < maxValueAllowed)
				{
					newMultiplication *= data[i];
				}
				else
				{
					flagAddValue = false;
				}
			}

			if (flagAddValue)
			{
				multiplications.push_back(newMultiplication);
			}
		}
	}

	return multiplications;
}


void Problem_012(void)
{
	Problem_012_t triangularNumber = 0;
	bool flagFound = false;
	// iterate through the triangular numbers
	Problem_012_t i = 1;
	while (!flagFound)
	{
		triangularNumber += i;	
		i++;

		// 1 is special case factor! - take it into account
		vector<Problem_012_t> factors;

		Problem_012_t value = triangularNumber;
		Problem_012_t currentFactor = 2;
		bool flagEnd = false;
		while (!flagEnd)
		{
			if (value % currentFactor == 0)
			{
				factors.push_back(currentFactor);
				value = value / currentFactor;
			}
			else
			{
				currentFactor++;
			}

			if ((value == 1) || (currentFactor > (triangularNumber / 2)))
			{
				flagEnd = true;
			}
		}

		vector<Problem_012_t> multiplications = AllPossibleMultiplicationsInSet(factors, triangularNumber/2);

		factors.push_back(1);
		factors.push_back(triangularNumber);

		// first idea to generate two elements permutations - longer were problematic with this approach
		// then add all available permutations
		//for (int j = 0; j < factors.size(); j++)
		//{
		//	int newFactor = 1;
		//	for (int k = j+1; k < factors.size(); k++)
		//	{
		//		newFactor = factors[j] * factors[k];
		//		if (newFactor < (triangularNumber / 2))
		//		{
		//			extendedFactors.insert(newFactor);
		//		}
		//	}
		//}

		set<Problem_012_t> extendedFactors;
		// copy all factors (without dupilcates) to set
		for (auto item : factors)
		{
			extendedFactors.insert(item);
		}
		// copy all multiplications of factors (without dupilcates) to set
		for (auto item : multiplications)
		{
			extendedFactors.insert(item);
		}
		
		if (extendedFactors.size() >= 100)
		{
			cout << "Triangular number: " << triangularNumber << endl;
			
			cout << "Basic factors: " << endl;
			for (auto item : factors)
			{
				cout << item << ", ";
			}
			cout << endl;

			cout << "Factors multiplications: " << endl;
			for (auto item : multiplications)
			{
				cout << item << ", ";
			}
			cout << endl;

			cout << "All factors: " << endl;
			for (auto item : extendedFactors)
			{
				cout << item << ", ";
			}
			cout << endl;

			flagFound = true;
		}
	}
}